import { ref, reactive, computed, nextTick } from 'vue';
import type { Message, ChatConfig } from '../types';
import { calculateCost } from '../constants/pricing';
import { ChatApiService } from '../services/chatApi';

// Simple ID generator
const generateId = () => Date.now().toString(36) + Math.random().toString(36).substr(2);

export function useChat() {
  // We use a Map to store all messages by ID
  const messageMap = reactive(new Map<string, Message>());
  
  // Virtual root ID to anchor the first messages
  const rootId = ref<string | null>(null);
  
  const isLoading = ref(false);
  const abortController = ref<AbortController | null>(null);
  
  const apiService = new ChatApiService(import.meta.env.VITE_API_BASE_URL || '');

  // Computed property to reconstruct the linear conversation history based on selected branches
  const conversationHistory = computed(() => {
    const history: Message[] = [];
    if (!rootId.value) return history;

    // Traverse from root using selectedChildIndex
    let currentId: string | null = rootId.value;
    
    while (currentId && messageMap.has(currentId)) {
      const msg = messageMap.get(currentId)!;
      history.push(msg);
      
      if (msg.childrenIds.length > 0) {
        // If selectedChildIndex is within bounds, traverse down
        // If selectedChildIndex === childrenIds.length, it means we are "drafting" a new branch, so stop here.
        if (msg.selectedChildIndex < msg.childrenIds.length) {
          currentId = msg.childrenIds[msg.selectedChildIndex];
        } else {
          currentId = null;
        }
      } else {
        currentId = null;
      }
    }
    return history;
  });

  // Helper to create a new message node
  const createMessageNode = (
    role: 'user' | 'model', 
    text: string, 
    parentId: string | null
  ): Message => ({
    id: generateId(),
    role,
    parts: [{ text }],
    parentId,
    childrenIds: [],
    selectedChildIndex: 0,
    timestamp: Date.now()
  });

  const addMessage = (partialMsg: Partial<Message>) => {
    const parentId = partialMsg.parentId ?? null;
    const newMessage = {
      ...createMessageNode(partialMsg.role || 'user', partialMsg.parts?.[0].text || '', parentId),
      ...partialMsg
    };
    
    messageMap.set(newMessage.id, newMessage);

    if (parentId) {
      const parent = messageMap.get(parentId);
      if (parent) {
        parent.childrenIds.push(newMessage.id);
        // Auto-select the new message
        parent.selectedChildIndex = parent.childrenIds.length - 1;
      }
    } else {
      // If no parent, and no root, make it root
      if (!rootId.value) {
        rootId.value = newMessage.id;
      }
    }
    return newMessage;
  };

  const deleteMessage = (id: string) => {
    const msg = messageMap.get(id);
    if (!msg) return;

    // Helper to recursively delete subtree
    const deleteSubtree = (nodeId: string) => {
      const node = messageMap.get(nodeId);
      if (node) {
        node.childrenIds.forEach(deleteSubtree);
        messageMap.delete(nodeId);
      }
    };

    // Remove from parent's children
    if (msg.parentId) {
      const parent = messageMap.get(msg.parentId);
      if (parent) {
        const index = parent.childrenIds.indexOf(id);
        if (index !== -1) {
          parent.childrenIds.splice(index, 1);
          // Adjust selectedChildIndex if needed
          if (parent.selectedChildIndex >= parent.childrenIds.length) {
            parent.selectedChildIndex = Math.max(0, parent.childrenIds.length - 1);
          }
        }
      }
    } else {
      // If root
      if (rootId.value === id) {
        rootId.value = null;
      }
    }

    deleteSubtree(id);
  };

  const updateLastMessage = (text: string, append = true) => {
    const history = conversationHistory.value;
    const lastMsg = history[history.length - 1];
    if (lastMsg && lastMsg.role === 'model') {
       if (!append) {
           lastMsg.parts[0].text = text;
       } else {
           lastMsg.parts[0].text += text;
       }
    }
  };

  const stopGeneration = () => {
    if (abortController.value) {
      abortController.value.abort();
    }
  };

  // Branching Logic
  const createBranch = (parentId: string) => {
    const parent = messageMap.get(parentId);
    if (parent) {
      // Set selected index to 'length', effectively pointing to a non-existent child (Draft Mode)
      parent.selectedChildIndex = parent.childrenIds.length;
    }
  };

  const switchBranch = (parentId: string, index: number) => {
    const parent = messageMap.get(parentId);
    if (parent) {
      if (index >= 0 && index <= parent.childrenIds.length) {
         parent.selectedChildIndex = index;
      }
    }
  };

  const sendMessage = async (input: string, config: ChatConfig, onStreamUpdate: () => void) => {
    if (!input.trim() || isLoading.value) return;

    isLoading.value = true;
    abortController.value = new AbortController();

    // Determine Parent ID
    // The last message in the CURRENT view is the parent of the new user message.
    const history = conversationHistory.value;
    const parentMsg = history.length > 0 ? history[history.length - 1] : null;
    const parentId = parentMsg ? parentMsg.id : null;

    // 1. Add User Message
    const userMsg = addMessage({
      role: 'user',
      parts: [{ text: input }],
      sentChars: input.length,
      parentId
    });

    // 2. Add Placeholder Model Message
    const modelMsg = addMessage({ 
      role: 'model', 
      parts: [{ text: '思考中...' }],
      parentId: userMsg.id
    });
    
    // Prepare history for API (all messages leading up to userMsg, inclusive)
    // conversationHistory now includes [..., parent, userMsg, modelMsg]
    // We want to send [..., parent, userMsg]
    // We can just take conversationHistory.value.slice(0, -1) because modelMsg is the last one.
    
    let isFirstChunk = true;
    let fullText = '';

    try {
      await apiService.sendMessageStream(
        conversationHistory.value.slice(0, -1),
        config,
        abortController.value.signal,
        {
          onChunk: (text) => {
            if (isFirstChunk) {
              updateLastMessage(text, false);
              isFirstChunk = false;
            } else {
              updateLastMessage(text, true);
            }
            fullText += text;
            onStreamUpdate();
          },
          onMetadata: (usage) => {
            const { inputCost, outputCost } = calculateCost(config.model, usage.promptTokenCount, usage.candidatesTokenCount);
            if (modelMsg) {
                modelMsg.inputTokens = usage.promptTokenCount;
                modelMsg.outputTokens = usage.candidatesTokenCount;
                modelMsg.inputCost = inputCost;
                modelMsg.outputCost = outputCost;
            }
          },
          onError: (err) => { throw err; }
        }
      );
      
      modelMsg.receivedChars = fullText.length;

    } catch (error: any) {
      if (modelMsg) {
          if (error.name === 'AbortError') {
             const stopText = '\n\n**[生成已手动停止]**';
             if (modelMsg.parts[0].text === '思考中...') {
                 modelMsg.parts[0].text = '**[生成已手动停止]**';
             } else {
                 modelMsg.parts[0].text += stopText;
             }
          } else {
             modelMsg.parts[0].text = `**Error:** ${error.message || 'Unknown error'}`;
          }
      }
      onStreamUpdate();
    } finally {
      isLoading.value = false;
      abortController.value = null;
    }
  };

  return {
    conversationHistory,
    isLoading,
    sendMessage,
    stopGeneration,
    deleteMessage,
    createBranch,
    switchBranch
  };
}
