<template>
  <div id="app" :style="{ '--base-font-size': selectedFontSize }">
      <!-- 使用 template 标签和 v-if 来包裹整个聊天界面 -->
    <template v-if="isAuthenticated">
    <div id="header">
      <h1>我的 Gemini 客户端</h1>
      <div id="settings">
        <!-- 注意：模型名称已更新以匹配价格表中的键名 -->
		<select v-model="selectedModel">
		  <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
		  <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
		</select>
        <select v-model="contextLength" title="选择上下文轮次">
          <option value="all">全部对话</option>
          <option value="20">最近10轮</option>
          <option value="12">最近6轮</option>
          <option value="8">最近4轮</option>
          <option value="4">最近2轮</option>
          <option value="0">无上下文</option>
        </select>
        <!-- 在“选择上下文轮次”的 select 后面添加 -->
        <select v-model="selectedFontSize" title="选择字体大小">
          <option value="12px">小</option>
          <option value="13px">默认</option>
          <option value="14px">中</option>
          <option value="16px">大</option>
        </select>
      </div>
    </div>
    <div id="chat-window" ref="chatWindowRef" @scroll="handleScroll">
      <div v-for="(message, index) in conversationHistory" :key="index" :class="['message', message.role]">
        <div class="role">{{ message.role === 'user' ? 'You' : 'Model' }}</div>
        <div class="text" v-if="message.role === 'user'">{{ message.parts[0].text }}</div>
        <div class="text" v-else v-html="renderMarkdown(message.parts[0].text)"></div>
        <!-- 原始字符统计信息 -->
        <div v-if="message.sentChars !== undefined || message.receivedChars !== undefined" class="token-info">
          <span v-if="message.sentChars !== undefined">发送字符数: {{ message.sentChars }}</span>
          <span v-if="message.receivedChars !== undefined" class="received-chars">接收字符数: {{ message.receivedChars }}</span>
        </div>
        <!-- 新增：Token 和费用信息 -->
        <div v-if="message.inputTokens !== undefined" class="token-info cost-info">
          <span title="输入 Token 数及费用 (USD)">
            消耗: {{ message.inputTokens }} tokens (≈ ${{ message.inputCost?.toFixed(6) }})
          </span>
          <span title="输出 Token 数及费用 (USD)" class="received-chars">
            生成: {{ message.outputTokens }} tokens (≈ ${{ message.outputCost?.toFixed(6) }})
          </span>
        </div>
      </div>
    </div>
	<button v-if="showCompletionHint" @click="forceScrollToBottom" class="completion-hint" title="滚动到底部">
	  ↓ 新消息
	</button>

    <div id="input-area">
      <textarea
        id="message-input"
        placeholder="在这里输入消息... (Shift+Enter 换行)"
        rows="1"
        v-model="userInput"
        @keydown.enter.prevent.exact="sendMessage"
        @keydown.shift.enter.prevent
        @keyup.shift.enter="userInput += '\n'; autoResizeTextarea($event)"
        @input="autoResizeTextarea"
        :disabled="isLoading"
        ref="textareaRef"
      ></textarea>
      <button
        id="send-button"
        :title="isLoading ? '停止生成' : '发送'"
        @click="isLoading ? stopGeneration() : sendMessage()"
        :disabled="!userInput.trim() && !isLoading"
        :class="{ 'stop-button': isLoading }"
      >
        <span v-if="isLoading">✕</span>
        <span v-else>➤</span>
      </button>
    </div>
    </template> <!-- 这是 v-if="isAuthenticated" 的结束标签 -->   

    <!-- 新增：当验证失败时，显示这个访问受限的界面 -->
    <div v-else class="access-denied">
      <h2>🔒 访问受限</h2>
      <p>请通过包含有效访问令牌的链接访问此页面。</p>
      <p class="warning">
        <strong>重要:</strong> 如果您的令牌包含 <code>#</code>, <code>+</code>, <code>&</code>, <code>%</code> 等特殊字符,
        您必须使用 <strong>URL编码后</strong> 的令牌。
      </p>
      <p>
        <strong>错误示例:</strong> <code>.../?token=my#secret+key</code><br>
        <strong>正确示例:</strong> <code>.../?token=my%23secret%2Bkey</code>
      </p>
    </div>
        
  </div>
</template>

<script setup lang="ts">
import { ref, nextTick, onMounted, onUnmounted } from 'vue';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import type { Tokens } from 'marked';

// --- 新增：价格和汇率配置 ---
// 价格来源: Google AI Platform 定价 (USD per 1 million tokens)
// 注意：这里我们只处理了“标准”使用场景下的文本输入定价。
const MODEL_PRICING = {
  'gemini-2.5-pro': {
    // 价格分层，以输入 token 数为依据
    tier1: {
      threshold: 200000, // 阈值：<= 200k tokens
      input: 1.25,
      output: 10.00,
    },
    tier2: { // > 200k tokens
      input: 2.50,
      output: 15.00,
    },
  },
  'gemini-2.5-flash': {
    // 固定价格
    input: 0.30,
    output: 2.50,
  },
};

// 兼容旧的模型名称，映射到新的
const MODEL_NAME_MAPPING: { [key: string]: keyof typeof MODEL_PRICING } = {
  'gemini-2.5-pro': 'gemini-2.5-pro',
  'gemini-2.5-flash': 'gemini-2.5-flash',
}


// --- 类型定义 (已扩展) ---
interface MessagePart {
  text: string;
}
interface Message {
  role: 'user' | 'model';
  // 将 parts 的类型从 MessagePart[] 修改为 [MessagePart, ...MessagePart[]]
  // 这表示 parts 数组至少包含一个 MessagePart 元素
  parts: [MessagePart, ...MessagePart[]];
  sentChars?: number;
  receivedChars?: number;
  // 新增：用于存储 token 和费用信息
  inputTokens?: number;
  outputTokens?: number;
  inputCost?: number;
  outputCost?: number;
}

// --- 响应式状态 ---
const userInput = ref('');
const conversationHistory = ref<Message[]>([]);
const selectedModel = ref<keyof typeof MODEL_PRICING>('gemini-2.5-flash'); // 默认模型
const contextLength = ref('12'); // 默认最近6轮
const isLoading = ref(false);
const shouldAutoScroll = ref(true); // 新增：用于控制当前消息是否自动滚动
const abortController = ref<AbortController | null>(null);
const showCompletionHint = ref(false);
const isAuthenticated = ref(false); // 新增：用于控制访问权限
const selectedFontSize = ref('13px'); // 新增：用于控制全局字体大小

// --- DOM 引用 ---
const chatWindowRef = ref<HTMLElement | null>(null);
const textareaRef = ref<HTMLTextAreaElement | null>(null);
// 注意：streamBuffer 和 rendererIntervalId 已被移除

// --- API 配置 ---
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || '';


// --- 方法 ---

// 自动滚动到底部 (无需修改)
const scrollToBottom = (force = false) => {
  nextTick(() => {
    const chatWindow = chatWindowRef.value;
    if (chatWindow) {
      const isScrolledToBottom = chatWindow.scrollHeight - chatWindow.scrollTop - chatWindow.clientHeight < 100;
      if (force || isScrolledToBottom) {
        chatWindow.scrollTop = chatWindow.scrollHeight;
      }
    }
  });
};

// 动态调整文本框高度 (已修正，支持智能滚动)
const autoResizeTextarea = (event: Event) => {
  const textarea = event.target as HTMLTextAreaElement;

  // --- 新增：在调整大小前，检查滚动条是否在底部 ---
  // 我们设置一个小的容差值（例如 5px），以防计算出现微小误差
  const isScrolledToBottom = textarea.scrollHeight - textarea.scrollTop - textarea.clientHeight < 5;

  // 保持原有的高度调整逻辑
  textarea.style.height = 'auto';
  const newHeight = Math.min(textarea.scrollHeight, 120);
  textarea.style.height = `${newHeight}px`;

  // --- 修改：只有当用户之前就在底部时，才执行滚动 ---
  // 这样，当用户在中间编辑时，视图不会跳动
  if (isScrolledToBottom) {
    textarea.scrollTop = textarea.scrollHeight;
  }
};

// --- 为 marked 创建并配置自定义渲染器 ---
const renderer = new marked.Renderer();
const originalCodeRenderer = renderer.code; // 保存原始的 code 渲染器

// 最终正确的签名：函数接收一个完整的 Tokens.Code 对象
renderer.code = function(codeToken: Tokens.Code) {
  // 关键修正：将接收到的【原始 codeToken 对象】完整地传回给原始渲染器
  const rawCodeBlock = originalCodeRenderer.call(this, codeToken);
  
  const copyButton = `
    <button class="copy-code-button" title="Copy code">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
      <span class="copy-text">Copy</span>
    </button>
  `;
  
  return `<div class="code-block-wrapper">${copyButton}${rawCodeBlock}</div>`;
};

// --- 告诉 marked 使用我们配置好的渲染器 ---
marked.use({ renderer });

// 安全地渲染 Markdown (无需修改)
const renderMarkdown = (text: string) => {
  marked.setOptions({
    gfm: true,
    breaks: true,
  });
  return DOMPurify.sanitize(marked.parse(text) as string);
};

// --- 新增：计费函数 ---
const calculateCost = (model: keyof typeof MODEL_PRICING, inputTokens: number, outputTokens: number) => {
  const modelPricingInfo = MODEL_PRICING[model];
  if (!modelPricingInfo) {
    return { inputCost: 0, outputCost: 0 };
  }

  let inputPrice = 0;
  let outputPrice = 0;

  // 检查是否为具有分层定价的 Pro 模型
  if (model === 'gemini-2.5-pro' && 'tier1' in modelPricingInfo) {
    if (inputTokens <= modelPricingInfo.tier1.threshold) {
      inputPrice = modelPricingInfo.tier1.input;
      outputPrice = modelPricingInfo.tier1.output;
    } else {
      inputPrice = modelPricingInfo.tier2.input;
      outputPrice = modelPricingInfo.tier2.output;
    }
  } else if ('input' in modelPricingInfo) { // 处理像 Flash 这样的固定价格模型
    inputPrice = modelPricingInfo.input;
    outputPrice = modelPricingInfo.output;
  }

  const inputCost = (inputTokens / 1_000_000) * inputPrice;
  const outputCost = (outputTokens / 1_000_000) * outputPrice;

  return { inputCost, outputCost }; // 直接返回美元成本
};

// 发送消息 (核心逻辑修改)
const sendMessage = async () => {
    showCompletionHint.value = false;
    const trimmedInput = userInput.value.trim();
    if (!trimmedInput || isLoading.value) return;

    isLoading.value = true;
    abortController.value = new AbortController();
    shouldAutoScroll.value = true;

    let historyForPayload: Message[] = [];
    if (contextLength.value === 'all') {
        historyForPayload = conversationHistory.value;
    } else {
        const length = parseInt(contextLength.value, 10);
        if (length > 0) {
            historyForPayload = conversationHistory.value.slice(-length);
        }
    }

    const payloadContents = [
        ...historyForPayload.map(msg => ({ role: msg.role, parts: msg.parts })),
        { role: 'user', parts: [{ text: trimmedInput }] }
    ];

    const userMessage: Message = {
        role: 'user',
        parts: [{ text: trimmedInput }],
        sentChars: trimmedInput.length
    };
    conversationHistory.value.push(userMessage);
    userInput.value = '';
    if (textareaRef.value) textareaRef.value.style.height = 'auto';
    scrollToBottom(true);

    const modelMessage: Message = { role: 'model', parts: [{ text: '思考中...' }] };
    conversationHistory.value.push(modelMessage);
    const modelMessageIndex = conversationHistory.value.length - 1;
    const apiModelName = MODEL_NAME_MAPPING[selectedModel.value] || selectedModel.value;

    try {
        const response = await fetch(`${API_BASE_URL}/api/chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: apiModelName,
                contents: payloadContents,
            }),
            signal: abortController.value.signal,
        });

        if (!response.ok || !response.body) {
            let errorText = `HTTP 错误! 状态: ${response.status}`;
            try {
                const errorData = await response.json();
                errorText = errorData.error?.message || JSON.stringify(errorData);
            } catch (e) { /* 忽略解析错误 */ }
            throw new Error(errorText);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullResponseText = '';
        let usageMetadata: { promptTokenCount: number; candidatesTokenCount: number } | null = null;
        let isFirstChunk = true;
        const chatWindow = chatWindowRef.value;
        if (chatWindow) {
            shouldAutoScroll.value = chatWindow.scrollHeight - chatWindow.scrollTop - chatWindow.clientHeight < 40;
        }

        while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const jsonStr = line.substring(6).trim();
                    if (!jsonStr || jsonStr === '[DONE]') continue;
                    try {
                        const data = JSON.parse(jsonStr);
                        const textContent = data.candidates?.[0]?.content?.parts?.[0]?.text;
                        if (textContent) {
                            const messageToUpdate = conversationHistory.value[modelMessageIndex]!;
                            if (isFirstChunk) {
                                messageToUpdate.parts[0].text = textContent;
                                isFirstChunk = false;
                            } else {
                                messageToUpdate.parts[0].text += textContent;
                            }
                            fullResponseText += textContent;
                            if (shouldAutoScroll.value) {
                                scrollToBottom(true);
                            }
                        }
                        if (data.usageMetadata) {
                            usageMetadata = data.usageMetadata;
                        }
                    } catch (e) {
                        console.error('无法解析 JSON 数据块:', jsonStr, e);
                    }
                }
            }
        }
        
        if (!shouldAutoScroll.value) {
          showCompletionHint.value = true;
        }

        const finalModelMessage = conversationHistory.value[modelMessageIndex]!;
        finalModelMessage.receivedChars = fullResponseText.length;
        if (usageMetadata) {
            const { promptTokenCount, candidatesTokenCount } = usageMetadata;
            const { inputCost, outputCost } = calculateCost(apiModelName, promptTokenCount, candidatesTokenCount);
            finalModelMessage.inputTokens = promptTokenCount;
            finalModelMessage.outputTokens = candidatesTokenCount;
            finalModelMessage.inputCost = inputCost;
            finalModelMessage.outputCost = outputCost;
        }

    } catch (error: any) {
        // --- 关键修改就在这个 catch 块里 ---
        const messageToUpdate = conversationHistory.value[modelMessageIndex];
        // 确保消息仍然存在，以防万一
        if (messageToUpdate) {
            if (error.name === 'AbortError') {
                console.log('生成已手动停止。');
                // 如果消息仍然是“思考中...”，则直接替换它
                if (messageToUpdate.parts[0].text === '思考中...') {
                    messageToUpdate.parts[0].text = '**[生成已手动停止]**';
                } else {
                    // 如果已经有部分内容，则在后面追加停止信息
                    messageToUpdate.parts[0].text += '\n\n**[生成已手动停止]**';
                }
            } else {
                console.error('发送消息时出错:', error);
                const errorMessage = error instanceof Error ? error.message : '未知错误';
                messageToUpdate.parts[0].text = `**出错了:** ${errorMessage}`;
            }
        }
        scrollToBottom(true);
    } finally {
        isLoading.value = false;
        abortController.value = null;
        nextTick(() => {
            textareaRef.value?.focus();
        });
    }
};

// 滚动事件处理器
const handleScroll = () => {
  const chatWindow = chatWindowRef.value;
  if (chatWindow) {
    const isNearBottom = chatWindow.scrollHeight - chatWindow.scrollTop - chatWindow.clientHeight < 40;

    // 核心修改：实时根据用户滚动位置更新自动滚动状态
    // 如果用户在底部附近，我们就认为他希望自动滚动。一旦他向上滚动，就立即禁用。
    shouldAutoScroll.value = isNearBottom;

    // 当用户快要滚动回底部时，自动隐藏提示按钮 (此逻辑保留)
    if (isNearBottom) {
      showCompletionHint.value = false;
    }
  }
};

// 强制滚动到底部并隐藏提示
const forceScrollToBottom = () => {
  scrollToBottom(true);
  showCompletionHint.value = false;
};

// 停止生成
const stopGeneration = () => {
  if (abortController.value) {
    abortController.value.abort();
    // isLoading 会在 sendMessage 的 finally 块中被设置为 false
  }
};

// 新增：处理复制按钮点击的函数 (事件委托)
const handleChatWindowClick = async (event: MouseEvent) => {
  const target = event.target as HTMLElement;
  // 使用 .closest() 来确保即使用户点击了按钮内的图标或文字也能找到按钮
  const copyButton = target.closest('.copy-code-button');

  // 如果点击的不是复制按钮，或者按钮已经处于“已复制”状态，则不执行任何操作
  if (!copyButton || copyButton.classList.contains('copied')) {
    return;
  }

  // 从按钮向上查找整个代码块的容器
  const wrapper = copyButton.closest('.code-block-wrapper');
  if (!wrapper) return;

  // 在容器内找到 <pre> 标签，它的 innerText 包含我们需要的纯文本代码
  const preElement = wrapper.querySelector('pre');
  if (!preElement) return;

  const codeToCopy = preElement.innerText;

  try {
    // 尝试将文本写入剪贴板
    await navigator.clipboard.writeText(codeToCopy);
    
    const copyText = copyButton.querySelector('.copy-text');
    if (copyText) {
      copyText.textContent = 'Copied!';
    }
    copyButton.classList.add('copied');

    // 2秒后恢复按钮状态
    setTimeout(() => {
      if (copyText) {
        copyText.textContent = 'Copy';
      }
      copyButton.classList.remove('copied');
    }, 2000);
  } catch (err) {
    console.error('Failed to copy text: ', err);
    const copyText = copyButton.querySelector('.copy-text');
    if (copyText) copyText.textContent = 'Error';
     setTimeout(() => {
      if (copyText) {
        copyText.textContent = 'Copy';
      }
    }, 2000);
  }
};

onMounted(() => {
  const SECRET_KEY = import.meta.env.VITE_ACCESS_KEY;
  if (!SECRET_KEY) {
    console.error("错误：未在 .env.local 文件中设置 VITE_ACCESS_KEY");
    isAuthenticated.value = false;
    return;
  }
  if (sessionStorage.getItem('app_access_key') === SECRET_KEY) {
    isAuthenticated.value = true;
  } else {
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    if (token === SECRET_KEY) {
      isAuthenticated.value = true;
      sessionStorage.setItem('app_access_key', SECRET_KEY);
      window.history.replaceState({}, document.title, window.location.pathname);
    }
  }

  if (isAuthenticated.value) {
    nextTick(() => { // 使用 nextTick 确保 DOM 已经渲染
        textareaRef.value?.focus();
        const chatWindow = chatWindowRef.value;
        if (chatWindow) {
          chatWindow.addEventListener('scroll', handleScroll);
          // 关键：在这里为父容器添加点击事件监听器
          chatWindow.addEventListener('click', handleChatWindowClick); 
        }
    });
  }
});

onUnmounted(() => {
  const chatWindow = chatWindowRef.value;
  if (chatWindow) {
    chatWindow.removeEventListener('scroll', handleScroll);
    // 关键：组件销毁时移除监听器，防止内存泄漏
    chatWindow.removeEventListener('click', handleChatWindowClick); 
  }
});
</script>

<style>
/* ... 你的所有现有 CSS 样式都保留 ... */
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background-color: #f4f4f9;
  margin: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  color: #333;
}

#app {
  width: 90%;
  max-width: 800px;
  height: 95vh;
  max-height: 900px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  font-size: var(--base-font-size, 13px); /* 确保有这一行 */
}

#header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 20px;
  border-bottom: 1px solid #eee;
  background-color: #fafafa;
  flex-shrink: 0;
}

h1 {
  font-size: 1.1em;
  color: #444;
  margin: 0;
  padding: 15px 0;
}

#settings {
  display: flex;
  align-items: center;
  gap: 10px;
}

#settings select {
  padding: 5px 8px;
  border-radius: 6px;
  border: 1px solid #ddd;
  font-size: 0.9em;
  background-color: #fff;
}

#chat-window {
  flex-grow: 1;
  overflow-y: auto;
  padding: 15px;
  display: flex;
  flex-direction: column;
}

.message {
  display: flex;
  flex-direction: column;
  margin-bottom: 15px;
  max-width: 95%;
}

.message .role {
  font-weight: bold;
  font-size: 0.85em;
  margin-bottom: 4px;
  color: #555;
}

.message .text {
  padding: 10px 15px;
  border-radius: 16px;
  line-height: 1.5;
  word-wrap: break-word;
  text-align: left;
}

.message.user {
  align-self: flex-end;
  align-items: flex-end;
}

.message.user .text {
  background: #007bff;
  color: white;
  border-bottom-right-radius: 4px;
  max-width: 100%; 
  white-space: pre-wrap;
  overflow-wrap: break-word;
  word-break: break-word; /* 新增：更强力地处理长单词或URL，确保其在气泡内换行 */
}

.message.model {
  align-self: flex-start;
  align-items: flex-start;
}

.message.model .text {
  background: #e9ecef;
  color: #333;
  border-bottom-left-radius: 4px;
  max-width: 100%;          /* 1. 定死宽度：强制气泡宽度不能超过其父容器 (.message.model) 的宽度 */
  overflow-wrap: break-word; /* 2. 文本换行：确保气泡内的普通长文本可以换行 */
  word-break: break-all;     /* 3. 强力换行：进一步确保非代码文本不会撑开气泡 */
}

.token-info {
  font-size: 0.75em;
  color: #888;
  margin-top: 5px;
  display: flex;
  gap: 12px; /* 增加了间距 */
}
.message.user .token-info {
  align-self: flex-end;
}
.message.model .token-info {
  align-self: flex-start;
}
.token-info .received-chars {
  color: #666;
}

/* --- 新增：费用信息样式 --- */
.cost-info {
  color: #6c757d; /* 使用更柔和的颜色 */
  margin-top: 3px;
}

.completion-hint {
  position: absolute;
  bottom: 75px; /* 调整位置，使其在输入框上方 */
  left: 50%;
  transform: translateX(-50%);
  z-index: 10;
  
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 20px;
  padding: 8px 16px;
  font-size: calc(var(--base-font-size, 13px) - 1px);
  font-weight: 500;
  cursor: pointer;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  transition: opacity 0.3s ease, transform 0.3s ease;
}

.completion-hint:hover {
  background-color: #0056b3;
  transform: translateX(-50%) translateY(-2px);
}

#input-area {
  display: flex;
  align-items: flex-end;
  padding: 12px;
  border-top: 1px solid #eee;
  background-color: #fafafa;
  flex-shrink: 0;
}

#message-input {
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 18px;
  padding: 10px 15px;
  resize: none;
  font-size: 1em;
  font-family: inherit;
  line-height: 1.4;
  max-height: 120px;
  overflow-y: auto;
}

#message-input:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
}

#send-button {
  background: #007bff;
  color: white;
  border: none;
  border-radius: 50%;
  width: 44px;
  height: 44px;
  margin-left: 10px;
  cursor: pointer;
  font-size: calc(var(--base-font-size, 13px) * 1.4);
  display: flex;
  justify-content: center;
  align-items: center;
  transition: background-color 0.2s;
  flex-shrink: 0;
}

#send-button.stop-button {
  background-color: #dc3545;
}
#send-button.stop-button:hover {
  background-color: #c82333;
}

#send-button:hover {
  background: #0056b3;
}

#send-button:disabled {
  background-color: #a0a0a0;
  cursor: not-allowed;
}

.message.model .text pre {
  background-color: #282c34;
  color: #abb2bf;
  padding: 0.8em;
  margin: 0.5em 0;
  border-radius: 8px;
  overflow-x: auto; /* 关键：这条规则本身是正确的，现在它的父元素行为正常了，它就能正确工作 */
  font-size: 0.9em;
  white-space: pre; /* 新增：明确指定代码块内的空白和换行行为，防止意外的自动换行 */
}
.message.model .text code {
  font-family: 'Courier New', Courier, monospace;
  background-color: rgba(0,0,0,0.08);
  padding: 2px 5px;
  border-radius: 4px;
}
.message.model .text pre > code {
  background-color: transparent;
  padding: 0;
  color: inherit;
}
.message.model .text blockquote {
  border-left: 3px solid #ccc;
  padding-left: 1em;
  margin: 0.5em 0;
  color: #666;
}
.message.model .text ul, .message.model .text ol {
  padding-left: 1.5em;
  margin: 0.5em 0;
}
.message.model .text p {
  margin: 0.5em 0;
}
.message.model .text p:first-child {
  margin-top: 0;
}
.message.model .text p:last-child {
  margin-bottom: 0;
}
.message.model .text strong {
  font-weight: bold;
}

/* --- 新增：访问受限页面的样式 --- */
.access-denied {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100%;
  padding: 20px;
  text-align: center;
  background-color: #f8f9fa;
  color: #495057;
}

.access-denied h2 {
  font-size: 2em;
  margin-bottom: 15px;
}

.access-denied p {
  font-size: 1.1em;
  margin-bottom: 20px;
  max-width: 500px;
  line-height: 1.6;
}

.access-denied code {
  background-color: #e9ecef;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: 'Courier New', Courier, monospace;
  color: #c7254e;
}

.access-denied .warning {
  background-color: #fff3cd;
  color: #856404;
  padding: 10px 15px;
  border-radius: 6px;
  border: 1px solid #ffeeba;
  max-width: 90%;
  margin-top: 20px;
  margin-bottom: 20px;
}

/* 
 * ===================================================================
 *  最终的、保证有效的滚动条样式 (Chrome/WebKit 核心)
 * ===================================================================
 */

/* 
 * -------------------------------------------------------------------
 *  A. 美化【页面主滚动条】(应用浅色主题)
 * -------------------------------------------------------------------
 *  我们不再对 #chat-window 进行修改，而是直接修改全局的滚动条。
 *  在您的布局中，这会稳定地应用到主聊天窗口的滚动条上。
 */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
  background-color: #f1f1f1; /* 轨道背景色 */
}

/* 定义滑块的样式 */
::-webkit-scrollbar-thumb {
  background-color: #c1c1c1; /* 滑块颜色 */
  border-radius: 4px;
}

/* 鼠标悬浮在滑块上时的样式 */
::-webkit-scrollbar-thumb:hover {
  background-color: #a8a8a8; /* 滑块颜色加深 */
}


/* 
 * -------------------------------------------------------------------
 *  B. 美化【代码块内部】的【水平】滚动条 (应用深色主题)
 *     这部分样式具有更高的特异性，会覆盖上面的全局设置。
 * -------------------------------------------------------------------
 */
.message.model .text pre::-webkit-scrollbar {
  /* 尺寸和轨道背景在代码块中需要重新定义 */
  height: 8px;
  background-color: #3d4451; /* 代码块滚动条的轨道颜色 */
}

/* 定义代码块中滑块的样式 */
.message.model .text pre::-webkit-scrollbar-thumb {
  background-color: #6c757d; /* 代码块滑块颜色 */
  border-radius: 4px;
  border: 2px solid #3d4451; /* 使用边框创建内边距效果，让滑块看起来更精致 */
}

/* 鼠标悬浮在代码块滑块上时的样式 */
.message.model .text pre::-webkit-scrollbar-thumb:hover {
  background-color: #9ea5ab; /* 悬浮时滑块颜色变亮 */
}

/* 
 * ===================================================================
 *  代码块复制按钮样式 (V2 - 专业版)
 * ===================================================================
 */

/* 
  1. Wrapper 容器: 
  - 成为视觉上的代码块主体 (背景、圆角等)
  - 作为按钮的相对定位父级
*/
.code-block-wrapper {
  position: relative;
  background-color: #2e3440; /* Nord 主题暗色背景 */
  border-radius: 8px;
  margin: 1em 0;
  padding: 1em; /* 为内部<pre>提供空间 */
}

/* 
  2. 内部 <pre> 标签: 
  - 重置其所有样式，使其透明地存在于 Wrapper 内部
  - 它的唯一作用是保留代码的格式
*/
.message.model .text .code-block-wrapper pre {
  margin: 0;
  padding: 0;
  background-color: transparent;
  overflow-x: auto; /* 保持代码水平滚动 */
}

/* 
  3. 复制按钮:
  - 绝对定位到 Wrapper 的右上角内部
  - 默认隐藏，悬浮时出现，交互友好
*/
.copy-code-button {
  position: absolute;
  top: 0.75em;
  right: 0.75em;
  
  display: flex;
  align-items: center;
  gap: 0.5em; /* 图标和文字的间距 */

  padding: 0.35em 0.6em;
  background-color: rgba(216, 222, 233, 0.1); /* Nord 主题的半透明背景 */
  color: #d8dee9; /* Nord 主题的文字颜色 */
  border: 1px solid rgba(216, 222, 233, 0.15);
  border-radius: 6px;
  font-size: 0.875rem;
  font-family: inherit;
  cursor: pointer;
  
  opacity: 0; /* 默认完全透明 */
  transform: translateY(-5px); /* 默认向上移动一点 */
  transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out, background-color 0.2s;
  z-index: 10;
}

/* 
  4. 交互效果:
  - 当鼠标悬浮在【整个代码块】上时，按钮平滑地浮现出来
*/
.code-block-wrapper:hover .copy-code-button {
  opacity: 1;
  transform: translateY(0);
}

.copy-code-button:hover {
  background-color: rgba(216, 222, 233, 0.25);
}

.copy-code-button:active {
  background-color: rgba(216, 222, 233, 0.3);
}

/* 
  5. 复制成功状态:
  - 按钮背景变绿，文字和图标变白
*/
.copy-code-button.copied {
  background-color: #5e81ac; /* Nord 主题的蓝色，表示成功 */
  border-color: #5e81ac;
  color: #eceff4;
}

.copy-code-button .copy-text {
  line-height: 1; /* 确保文字垂直居中 */
}
</style>