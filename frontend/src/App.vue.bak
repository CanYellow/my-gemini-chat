<template>
<<<<<<< HEAD
  <div id="app" :style="{ '--base-font-size': selectedFontSize }">
      <!-- ä½¿ç”¨ template æ ‡ç­¾å’Œ v-if æ¥åŒ…è£¹æ•´ä¸ªèŠå¤©ç•Œé¢ -->
    <template v-if="isAuthenticated">
    <div id="header">
      <h1>æˆ‘çš„ Gemini å®¢æˆ·ç«¯</h1>
      <div id="settings">
        <!-- æ³¨æ„ï¼šæ¨¡å‹åç§°å·²æ›´æ–°ä»¥åŒ¹é…ä»·æ ¼è¡¨ä¸­çš„é”®å -->
		<select v-model="selectedModel">
		  <option value="gemini-2.5-pro">Gemini 2.5 Pro</option>
		  <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
		</select>
        <select v-model="contextLength" title="é€‰æ‹©ä¸Šä¸‹æ–‡è½®æ¬¡">
          <option value="all">å…¨éƒ¨å¯¹è¯</option>
          <option value="20">æœ€è¿‘10è½®</option>
          <option value="12">æœ€è¿‘6è½®</option>
          <option value="8">æœ€è¿‘4è½®</option>
          <option value="4">æœ€è¿‘2è½®</option>
          <option value="0">æ— ä¸Šä¸‹æ–‡</option>
        </select>
        <!-- åœ¨â€œé€‰æ‹©ä¸Šä¸‹æ–‡è½®æ¬¡â€çš„ select åé¢æ·»åŠ  -->
        <select v-model="selectedFontSize" title="é€‰æ‹©å­—ä½“å¤§å°">
          <option value="12px">å°</option>
          <option value="13px">é»˜è®¤</option>
          <option value="14px">ä¸­</option>
          <option value="16px">å¤§</option>
        </select>
      </div>
    </div>
    <div id="chat-window" ref="chatWindowRef" @scroll="handleScroll">
      <div v-for="(message, index) in conversationHistory" :key="index" :class="['message', message.role]">
        <div class="role">{{ message.role === 'user' ? 'You' : 'Model' }}</div>
        <div class="text" v-if="message.role === 'user'">{{ message.parts[0].text }}</div>
        <div class="text" v-else v-html="renderMarkdown(message.parts[0].text)"></div>
        <!-- åŸå§‹å­—ç¬¦ç»Ÿè®¡ä¿¡æ¯ -->
        <div v-if="message.sentChars !== undefined || message.receivedChars !== undefined" class="token-info">
          <span v-if="message.sentChars !== undefined">å‘é€å­—ç¬¦æ•°: {{ message.sentChars }}</span>
          <span v-if="message.receivedChars !== undefined" class="received-chars">æ¥æ”¶å­—ç¬¦æ•°: {{ message.receivedChars }}</span>
        </div>
        <!-- æ–°å¢ï¼šToken å’Œè´¹ç”¨ä¿¡æ¯ -->
        <div v-if="message.inputTokens !== undefined" class="token-info cost-info">
          <span title="è¾“å…¥ Token æ•°åŠè´¹ç”¨ (USD)">
            æ¶ˆè€—: {{ message.inputTokens }} tokens (â‰ˆ ${{ message.inputCost?.toFixed(6) }})
          </span>
          <span title="è¾“å‡º Token æ•°åŠè´¹ç”¨ (USD)" class="received-chars">
            ç”Ÿæˆ: {{ message.outputTokens }} tokens (â‰ˆ ${{ message.outputCost?.toFixed(6) }})
          </span>
        </div>
      </div>
    </div>
	<button v-if="showCompletionHint" @click="forceScrollToBottom" class="completion-hint" title="æ»šåŠ¨åˆ°åº•éƒ¨">
	  â†“ æ–°æ¶ˆæ¯
	</button>

    <div id="input-area">
      <textarea
        id="message-input"
        placeholder="åœ¨è¿™é‡Œè¾“å…¥æ¶ˆæ¯... (Shift+Enter æ¢è¡Œ)"
        rows="1"
        v-model="userInput"
        @keydown.enter.prevent.exact="sendMessage"
        @keydown.shift.enter.prevent
        @keyup.shift.enter="userInput += '\n'; autoResizeTextarea($event)"
        @input="autoResizeTextarea"
        :disabled="isLoading"
        ref="textareaRef"
      ></textarea>
      <button
        id="send-button"
        :title="isLoading ? 'åœæ­¢ç”Ÿæˆ' : 'å‘é€'"
        @click="isLoading ? stopGeneration() : sendMessage()"
        :disabled="!userInput.trim() && !isLoading"
        :class="{ 'stop-button': isLoading }"
      >
        <span v-if="isLoading">âœ•</span>
        <span v-else>â¤</span>
      </button>
    </div>
    </template> <!-- è¿™æ˜¯ v-if="isAuthenticated" çš„ç»“æŸæ ‡ç­¾ -->   

    <!-- æ–°å¢ï¼šå½“éªŒè¯å¤±è´¥æ—¶ï¼Œæ˜¾ç¤ºè¿™ä¸ªè®¿é—®å—é™çš„ç•Œé¢ -->
    <div v-else class="access-denied">
      <h2>ğŸ”’ è®¿é—®å—é™</h2>
      <p>è¯·é€šè¿‡åŒ…å«æœ‰æ•ˆè®¿é—®ä»¤ç‰Œçš„é“¾æ¥è®¿é—®æ­¤é¡µé¢ã€‚</p>
      <p class="warning">
        <strong>é‡è¦:</strong> å¦‚æœæ‚¨çš„ä»¤ç‰ŒåŒ…å« <code>#</code>, <code>+</code>, <code>&</code>, <code>%</code> ç­‰ç‰¹æ®Šå­—ç¬¦,
        æ‚¨å¿…é¡»ä½¿ç”¨ <strong>URLç¼–ç å</strong> çš„ä»¤ç‰Œã€‚
      </p>
      <p>
        <strong>é”™è¯¯ç¤ºä¾‹:</strong> <code>.../?token=my#secret+key</code><br>
        <strong>æ­£ç¡®ç¤ºä¾‹:</strong> <code>.../?token=my%23secret%2Bkey</code>
      </p>
    </div>
        
=======
  <div id="app" :style="{ '--base-font-size': fontSize }">
    <template v-if="isAuthenticated">
      <!-- Header with Title, Settings Button and Global Actions -->
      <AppSettings
        v-model:title="pageTitle"
        v-model:fontSize="fontSize"
        @openSettings="showSettings = true"
        @collapseAll="handleGlobalCollapse"
        @expandAll="handleGlobalExpand"
      />

      <div id="chat-window" ref="chatWindowRef" @scroll="handleScroll" @click="handleCopyClick">
        <ChatMessage 
          v-for="(msg, index) in conversationHistory" 
          :key="msg.id" 
          :message="msg" 
          @delete="handleDelete"
        />
      </div>

      <button v-if="showCompletionHint" @click="handleHintClick" class="completion-hint">
        {{ hintText }}
      </button>

      <!-- Settings Bar (Model, Context, etc.) -->
      <ChatSettings
        v-model:model="model"
        v-model:contextLength="contextLength"
        v-model:temperature="temperature"
        v-model:topP="topP"
      />

      <ChatInput 
        :isLoading="isLoading" 
        @send="onSend" 
        @stop="stopGeneration" 
        ref="inputRef"
      />

      <!-- Global Settings Modal -->
      <GlobalSettings v-if="showSettings" @close="showSettings = false" />
    </template>

    <AccessDenied v-else />
>>>>>>> 15934b618b20a489a8e8f54099124f82bf2036a5
  </div>
</template>

<script setup lang="ts">
<<<<<<< HEAD
import { ref, nextTick, onMounted, onUnmounted } from 'vue';
import { marked } from 'marked';
import DOMPurify from 'dompurify';
import type { Tokens } from 'marked';

// --- æ–°å¢ï¼šä»·æ ¼å’Œæ±‡ç‡é…ç½® ---
// ä»·æ ¼æ¥æº: Google AI Platform å®šä»· (USD per 1 million tokens)
// æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬åªå¤„ç†äº†â€œæ ‡å‡†â€ä½¿ç”¨åœºæ™¯ä¸‹çš„æ–‡æœ¬è¾“å…¥å®šä»·ã€‚
const MODEL_PRICING = {
  'gemini-2.5-pro': {
    // ä»·æ ¼åˆ†å±‚ï¼Œä»¥è¾“å…¥ token æ•°ä¸ºä¾æ®
    tier1: {
      threshold: 200000, // é˜ˆå€¼ï¼š<= 200k tokens
      input: 1.25,
      output: 10.00,
    },
    tier2: { // > 200k tokens
      input: 2.50,
      output: 15.00,
    },
  },
  'gemini-2.5-flash': {
    // å›ºå®šä»·æ ¼
    input: 0.30,
    output: 2.50,
  },
};

// å…¼å®¹æ—§çš„æ¨¡å‹åç§°ï¼Œæ˜ å°„åˆ°æ–°çš„
const MODEL_NAME_MAPPING: { [key: string]: keyof typeof MODEL_PRICING } = {
  'gemini-2.5-pro': 'gemini-2.5-pro',
  'gemini-2.5-flash': 'gemini-2.5-flash',
}


// --- ç±»å‹å®šä¹‰ (å·²æ‰©å±•) ---
interface MessagePart {
  text: string;
}
interface Message {
  role: 'user' | 'model';
  // å°† parts çš„ç±»å‹ä» MessagePart[] ä¿®æ”¹ä¸º [MessagePart, ...MessagePart[]]
  // è¿™è¡¨ç¤º parts æ•°ç»„è‡³å°‘åŒ…å«ä¸€ä¸ª MessagePart å…ƒç´ 
  parts: [MessagePart, ...MessagePart[]];
  sentChars?: number;
  receivedChars?: number;
  // æ–°å¢ï¼šç”¨äºå­˜å‚¨ token å’Œè´¹ç”¨ä¿¡æ¯
  inputTokens?: number;
  outputTokens?: number;
  inputCost?: number;
  outputCost?: number;
}

// --- å“åº”å¼çŠ¶æ€ ---
const userInput = ref('');
const conversationHistory = ref<Message[]>([]);
const selectedModel = ref<keyof typeof MODEL_PRICING>('gemini-2.5-flash'); // é»˜è®¤æ¨¡å‹
const contextLength = ref('12'); // é»˜è®¤æœ€è¿‘6è½®
const isLoading = ref(false);
const shouldAutoScroll = ref(true); // æ–°å¢ï¼šç”¨äºæ§åˆ¶å½“å‰æ¶ˆæ¯æ˜¯å¦è‡ªåŠ¨æ»šåŠ¨
const abortController = ref<AbortController | null>(null);
const showCompletionHint = ref(false);
const isAuthenticated = ref(false); // æ–°å¢ï¼šç”¨äºæ§åˆ¶è®¿é—®æƒé™
const selectedFontSize = ref('13px'); // æ–°å¢ï¼šç”¨äºæ§åˆ¶å…¨å±€å­—ä½“å¤§å°

// --- DOM å¼•ç”¨ ---
const chatWindowRef = ref<HTMLElement | null>(null);
const textareaRef = ref<HTMLTextAreaElement | null>(null);
// æ³¨æ„ï¼šstreamBuffer å’Œ rendererIntervalId å·²è¢«ç§»é™¤

// --- API é…ç½® ---
const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || '';


// --- æ–¹æ³• ---

// è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨ (æ— éœ€ä¿®æ”¹)
const scrollToBottom = (force = false) => {
  nextTick(() => {
    const chatWindow = chatWindowRef.value;
    if (chatWindow) {
      const isScrolledToBottom = chatWindow.scrollHeight - chatWindow.scrollTop - chatWindow.clientHeight < 100;
      if (force || isScrolledToBottom) {
        chatWindow.scrollTop = chatWindow.scrollHeight;
=======
import { ref, onMounted, nextTick, watch, computed } from 'vue';
import { useAuth } from './composables/useAuth';
import { useChat } from './composables/useChat';
import { useSettings } from './composables/useSettings';
import type { ModelKey } from './types';

// Components
import AppSettings from './components/header/AppSettings.vue';
import ChatMessage from './components/chat/ChatMessage.vue';
import ChatInput from './components/chat/ChatInput.vue';
import ChatSettings from './components/chat/ChatSettings.vue';
import AccessDenied from './components/auth/AccessDenied.vue';
import GlobalSettings from './components/settings/GlobalSettings.vue';

// State
const { isAuthenticated } = useAuth();
const { 
  conversationHistory, 
  isLoading, 
  currentGeneratingMessageId,
  sendMessage, 
  stopGeneration, 
  deleteMessage,
  navigateToMessage
} = useChat();
const { settings } = useSettings();

// UI State
const pageTitle = ref('æˆ‘çš„ Gemini å®¢æˆ·ç«¯');
const showSettings = ref(false);

// Model Settings
const model = ref<ModelKey>('gemini-2.5-flash');
const contextLength = ref('0');
const fontSize = ref('13px');
const temperature = ref(0.1);
const topP = ref(0.7);

// Update document title
watch(pageTitle, (newTitle) => {
  document.title = newTitle || 'Gemini Client';
}, { immediate: true });

// UI Refs & Scroll State
const chatWindowRef = ref<HTMLElement | null>(null);
const inputRef = ref<InstanceType<typeof ChatInput> | null>(null);
const showCompletionHint = ref(false);
const shouldAutoScroll = ref(true);

// Track the ID of a new message that is currently hidden (in another branch)
const pendingJumpMessageId = ref<string | null>(null);

// Watch conversation history to clear pending jump if the message becomes visible manually
watch(conversationHistory, (history) => {
  if (pendingJumpMessageId.value) {
    const isVisible = history.some(m => m.id === pendingJumpMessageId.value);
    if (isVisible) {
      pendingJumpMessageId.value = null;
      // Re-evaluate auto-scroll logic if needed, but usually manual navigation implies we are where we want to be.
    }
  }
});

// Computed Hint Logic
const isGeneratingMessageVisible = computed(() => {
  if (!currentGeneratingMessageId.value) return false;
  return conversationHistory.value.some(m => m.id === currentGeneratingMessageId.value);
});

const hintText = computed(() => {
  // If we have a pending hidden message (either generating or finished), show Jump hint
  if (pendingJumpMessageId.value) {
    return 'â†ª è·³è½¬åˆ°æ–°æ¶ˆæ¯åˆ†æ”¯';
  }
  return 'â†“ æ–°æ¶ˆæ¯';
});

// Scroll Logic
const scrollToBottom = (force = false) => {
  nextTick(() => {
    const el = chatWindowRef.value;
    if (el) {
      const isAtBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 100;
      if (force || isAtBottom) {
        el.scrollTop = el.scrollHeight;
>>>>>>> 15934b618b20a489a8e8f54099124f82bf2036a5
      }
    }
  });
};

<<<<<<< HEAD
// åŠ¨æ€è°ƒæ•´æ–‡æœ¬æ¡†é«˜åº¦ (å·²ä¿®æ­£ï¼Œæ”¯æŒæ™ºèƒ½æ»šåŠ¨)
const autoResizeTextarea = (event: Event) => {
  const textarea = event.target as HTMLTextAreaElement;

  // --- æ–°å¢ï¼šåœ¨è°ƒæ•´å¤§å°å‰ï¼Œæ£€æŸ¥æ»šåŠ¨æ¡æ˜¯å¦åœ¨åº•éƒ¨ ---
  // æˆ‘ä»¬è®¾ç½®ä¸€ä¸ªå°çš„å®¹å·®å€¼ï¼ˆä¾‹å¦‚ 5pxï¼‰ï¼Œä»¥é˜²è®¡ç®—å‡ºç°å¾®å°è¯¯å·®
  const isScrolledToBottom = textarea.scrollHeight - textarea.scrollTop - textarea.clientHeight < 5;

  // ä¿æŒåŸæœ‰çš„é«˜åº¦è°ƒæ•´é€»è¾‘
  textarea.style.height = 'auto';
  const newHeight = Math.min(textarea.scrollHeight, 120);
  textarea.style.height = `${newHeight}px`;

  // --- ä¿®æ”¹ï¼šåªæœ‰å½“ç”¨æˆ·ä¹‹å‰å°±åœ¨åº•éƒ¨æ—¶ï¼Œæ‰æ‰§è¡Œæ»šåŠ¨ ---
  // è¿™æ ·ï¼Œå½“ç”¨æˆ·åœ¨ä¸­é—´ç¼–è¾‘æ—¶ï¼Œè§†å›¾ä¸ä¼šè·³åŠ¨
  if (isScrolledToBottom) {
    textarea.scrollTop = textarea.scrollHeight;
  }
};

// --- ä¸º marked åˆ›å»ºå¹¶é…ç½®è‡ªå®šä¹‰æ¸²æŸ“å™¨ ---
const renderer = new marked.Renderer();
const originalCodeRenderer = renderer.code; // ä¿å­˜åŸå§‹çš„ code æ¸²æŸ“å™¨

// æœ€ç»ˆæ­£ç¡®çš„ç­¾åï¼šå‡½æ•°æ¥æ”¶ä¸€ä¸ªå®Œæ•´çš„ Tokens.Code å¯¹è±¡
renderer.code = function(codeToken: Tokens.Code) {
  // å…³é”®ä¿®æ­£ï¼šå°†æ¥æ”¶åˆ°çš„ã€åŸå§‹ codeToken å¯¹è±¡ã€‘å®Œæ•´åœ°ä¼ å›ç»™åŸå§‹æ¸²æŸ“å™¨
  const rawCodeBlock = originalCodeRenderer.call(this, codeToken);
  
  const copyButton = `
    <button class="copy-code-button" title="Copy code">
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
      <span class="copy-text">Copy</span>
    </button>
  `;
  
  return `<div class="code-block-wrapper">${copyButton}${rawCodeBlock}</div>`;
};

// --- å‘Šè¯‰ marked ä½¿ç”¨æˆ‘ä»¬é…ç½®å¥½çš„æ¸²æŸ“å™¨ ---
marked.use({ renderer });

// å®‰å…¨åœ°æ¸²æŸ“ Markdown (æ— éœ€ä¿®æ”¹)
const renderMarkdown = (text: string) => {
  marked.setOptions({
    gfm: true,
    breaks: true,
  });
  return DOMPurify.sanitize(marked.parse(text) as string);
};

// --- æ–°å¢ï¼šè®¡è´¹å‡½æ•° ---
const calculateCost = (model: keyof typeof MODEL_PRICING, inputTokens: number, outputTokens: number) => {
  const modelPricingInfo = MODEL_PRICING[model];
  if (!modelPricingInfo) {
    return { inputCost: 0, outputCost: 0 };
  }

  let inputPrice = 0;
  let outputPrice = 0;

  // æ£€æŸ¥æ˜¯å¦ä¸ºå…·æœ‰åˆ†å±‚å®šä»·çš„ Pro æ¨¡å‹
  if (model === 'gemini-2.5-pro' && 'tier1' in modelPricingInfo) {
    if (inputTokens <= modelPricingInfo.tier1.threshold) {
      inputPrice = modelPricingInfo.tier1.input;
      outputPrice = modelPricingInfo.tier1.output;
    } else {
      inputPrice = modelPricingInfo.tier2.input;
      outputPrice = modelPricingInfo.tier2.output;
    }
  } else if ('input' in modelPricingInfo) { // å¤„ç†åƒ Flash è¿™æ ·çš„å›ºå®šä»·æ ¼æ¨¡å‹
    inputPrice = modelPricingInfo.input;
    outputPrice = modelPricingInfo.output;
  }

  const inputCost = (inputTokens / 1_000_000) * inputPrice;
  const outputCost = (outputTokens / 1_000_000) * outputPrice;

  return { inputCost, outputCost }; // ç›´æ¥è¿”å›ç¾å…ƒæˆæœ¬
};

// å‘é€æ¶ˆæ¯ (æ ¸å¿ƒé€»è¾‘ä¿®æ”¹)
const sendMessage = async () => {
    showCompletionHint.value = false;
    const trimmedInput = userInput.value.trim();
    if (!trimmedInput || isLoading.value) return;

    isLoading.value = true;
    abortController.value = new AbortController();
    shouldAutoScroll.value = true;

    let historyForPayload: Message[] = [];
    if (contextLength.value === 'all') {
        historyForPayload = conversationHistory.value;
    } else {
        const length = parseInt(contextLength.value, 10);
        if (length > 0) {
            historyForPayload = conversationHistory.value.slice(-length);
        }
    }

    const payloadContents = [
        ...historyForPayload.map(msg => ({ role: msg.role, parts: msg.parts })),
        { role: 'user', parts: [{ text: trimmedInput }] }
    ];

    const userMessage: Message = {
        role: 'user',
        parts: [{ text: trimmedInput }],
        sentChars: trimmedInput.length
    };
    conversationHistory.value.push(userMessage);
    userInput.value = '';
    if (textareaRef.value) textareaRef.value.style.height = 'auto';
    scrollToBottom(true);

    const modelMessage: Message = { role: 'model', parts: [{ text: 'æ€è€ƒä¸­...' }] };
    conversationHistory.value.push(modelMessage);
    const modelMessageIndex = conversationHistory.value.length - 1;
    const apiModelName = MODEL_NAME_MAPPING[selectedModel.value] || selectedModel.value;

    try {
        const response = await fetch(`${API_BASE_URL}/api/chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: apiModelName,
                contents: payloadContents,
            }),
            signal: abortController.value.signal,
        });

        if (!response.ok || !response.body) {
            let errorText = `HTTP é”™è¯¯! çŠ¶æ€: ${response.status}`;
            try {
                const errorData = await response.json();
                errorText = errorData.error?.message || JSON.stringify(errorData);
            } catch (e) { /* å¿½ç•¥è§£æé”™è¯¯ */ }
            throw new Error(errorText);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let fullResponseText = '';
        let usageMetadata: { promptTokenCount: number; candidatesTokenCount: number } | null = null;
        let isFirstChunk = true;
        const chatWindow = chatWindowRef.value;
        if (chatWindow) {
            shouldAutoScroll.value = chatWindow.scrollHeight - chatWindow.scrollTop - chatWindow.clientHeight < 40;
        }

        while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            const chunk = decoder.decode(value, { stream: true });
            const lines = chunk.split('\n');
            for (const line of lines) {
                if (line.startsWith('data: ')) {
                    const jsonStr = line.substring(6).trim();
                    if (!jsonStr || jsonStr === '[DONE]') continue;
                    try {
                        const data = JSON.parse(jsonStr);
                        const textContent = data.candidates?.[0]?.content?.parts?.[0]?.text;
                        if (textContent) {
                            const messageToUpdate = conversationHistory.value[modelMessageIndex]!;
                            if (isFirstChunk) {
                                messageToUpdate.parts[0].text = textContent;
                                isFirstChunk = false;
                            } else {
                                messageToUpdate.parts[0].text += textContent;
                            }
                            fullResponseText += textContent;
                            if (shouldAutoScroll.value) {
                                scrollToBottom(true);
                            }
                        }
                        if (data.usageMetadata) {
                            usageMetadata = data.usageMetadata;
                        }
                    } catch (e) {
                        console.error('æ— æ³•è§£æ JSON æ•°æ®å—:', jsonStr, e);
                    }
                }
            }
        }
        
        if (!shouldAutoScroll.value) {
          showCompletionHint.value = true;
        }

        const finalModelMessage = conversationHistory.value[modelMessageIndex]!;
        finalModelMessage.receivedChars = fullResponseText.length;
        if (usageMetadata) {
            const { promptTokenCount, candidatesTokenCount } = usageMetadata;
            const { inputCost, outputCost } = calculateCost(apiModelName, promptTokenCount, candidatesTokenCount);
            finalModelMessage.inputTokens = promptTokenCount;
            finalModelMessage.outputTokens = candidatesTokenCount;
            finalModelMessage.inputCost = inputCost;
            finalModelMessage.outputCost = outputCost;
        }

    } catch (error: any) {
        // --- å…³é”®ä¿®æ”¹å°±åœ¨è¿™ä¸ª catch å—é‡Œ ---
        const messageToUpdate = conversationHistory.value[modelMessageIndex];
        // ç¡®ä¿æ¶ˆæ¯ä»ç„¶å­˜åœ¨ï¼Œä»¥é˜²ä¸‡ä¸€
        if (messageToUpdate) {
            if (error.name === 'AbortError') {
                console.log('ç”Ÿæˆå·²æ‰‹åŠ¨åœæ­¢ã€‚');
                // å¦‚æœæ¶ˆæ¯ä»ç„¶æ˜¯â€œæ€è€ƒä¸­...â€ï¼Œåˆ™ç›´æ¥æ›¿æ¢å®ƒ
                if (messageToUpdate.parts[0].text === 'æ€è€ƒä¸­...') {
                    messageToUpdate.parts[0].text = '**[ç”Ÿæˆå·²æ‰‹åŠ¨åœæ­¢]**';
                } else {
                    // å¦‚æœå·²ç»æœ‰éƒ¨åˆ†å†…å®¹ï¼Œåˆ™åœ¨åé¢è¿½åŠ åœæ­¢ä¿¡æ¯
                    messageToUpdate.parts[0].text += '\n\n**[ç”Ÿæˆå·²æ‰‹åŠ¨åœæ­¢]**';
                }
            } else {
                console.error('å‘é€æ¶ˆæ¯æ—¶å‡ºé”™:', error);
                const errorMessage = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯';
                messageToUpdate.parts[0].text = `**å‡ºé”™äº†:** ${errorMessage}`;
            }
        }
        scrollToBottom(true);
    } finally {
        isLoading.value = false;
        abortController.value = null;
        nextTick(() => {
            textareaRef.value?.focus();
        });
    }
};

// æ»šåŠ¨äº‹ä»¶å¤„ç†å™¨
const handleScroll = () => {
  const chatWindow = chatWindowRef.value;
  if (chatWindow) {
    const isNearBottom = chatWindow.scrollHeight - chatWindow.scrollTop - chatWindow.clientHeight < 40;

    // æ ¸å¿ƒä¿®æ”¹ï¼šå®æ—¶æ ¹æ®ç”¨æˆ·æ»šåŠ¨ä½ç½®æ›´æ–°è‡ªåŠ¨æ»šåŠ¨çŠ¶æ€
    // å¦‚æœç”¨æˆ·åœ¨åº•éƒ¨é™„è¿‘ï¼Œæˆ‘ä»¬å°±è®¤ä¸ºä»–å¸Œæœ›è‡ªåŠ¨æ»šåŠ¨ã€‚ä¸€æ—¦ä»–å‘ä¸Šæ»šåŠ¨ï¼Œå°±ç«‹å³ç¦ç”¨ã€‚
    shouldAutoScroll.value = isNearBottom;

    // å½“ç”¨æˆ·å¿«è¦æ»šåŠ¨å›åº•éƒ¨æ—¶ï¼Œè‡ªåŠ¨éšè—æç¤ºæŒ‰é’® (æ­¤é€»è¾‘ä¿ç•™)
    if (isNearBottom) {
=======
const handleScroll = () => {
  const el = chatWindowRef.value;
  if (el) {
    const isNearBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 40;
    shouldAutoScroll.value = isNearBottom;
    
    // Logic to hide hint:
    // 1. If we are near bottom AND (no hidden message pending OR hidden message is now visible)
    if (isNearBottom && !pendingJumpMessageId.value) {
>>>>>>> 15934b618b20a489a8e8f54099124f82bf2036a5
      showCompletionHint.value = false;
    }
  }
};

<<<<<<< HEAD
// å¼ºåˆ¶æ»šåŠ¨åˆ°åº•éƒ¨å¹¶éšè—æç¤º
=======
>>>>>>> 15934b618b20a489a8e8f54099124f82bf2036a5
const forceScrollToBottom = () => {
  scrollToBottom(true);
  showCompletionHint.value = false;
};

<<<<<<< HEAD
// åœæ­¢ç”Ÿæˆ
const stopGeneration = () => {
  if (abortController.value) {
    abortController.value.abort();
    // isLoading ä¼šåœ¨ sendMessage çš„ finally å—ä¸­è¢«è®¾ç½®ä¸º false
  }
};

// æ–°å¢ï¼šå¤„ç†å¤åˆ¶æŒ‰é’®ç‚¹å‡»çš„å‡½æ•° (äº‹ä»¶å§”æ‰˜)
const handleChatWindowClick = async (event: MouseEvent) => {
  const target = event.target as HTMLElement;
  // ä½¿ç”¨ .closest() æ¥ç¡®ä¿å³ä½¿ç”¨æˆ·ç‚¹å‡»äº†æŒ‰é’®å†…çš„å›¾æ ‡æˆ–æ–‡å­—ä¹Ÿèƒ½æ‰¾åˆ°æŒ‰é’®
  const copyButton = target.closest('.copy-code-button');

  // å¦‚æœç‚¹å‡»çš„ä¸æ˜¯å¤åˆ¶æŒ‰é’®ï¼Œæˆ–è€…æŒ‰é’®å·²ç»å¤„äºâ€œå·²å¤åˆ¶â€çŠ¶æ€ï¼Œåˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œ
  if (!copyButton || copyButton.classList.contains('copied')) {
    return;
  }

  // ä»æŒ‰é’®å‘ä¸ŠæŸ¥æ‰¾æ•´ä¸ªä»£ç å—çš„å®¹å™¨
  const wrapper = copyButton.closest('.code-block-wrapper');
  if (!wrapper) return;

  // åœ¨å®¹å™¨å†…æ‰¾åˆ° <pre> æ ‡ç­¾ï¼Œå®ƒçš„ innerText åŒ…å«æˆ‘ä»¬éœ€è¦çš„çº¯æ–‡æœ¬ä»£ç 
  const preElement = wrapper.querySelector('pre');
  if (!preElement) return;

  const codeToCopy = preElement.innerText;

  try {
    // å°è¯•å°†æ–‡æœ¬å†™å…¥å‰ªè´´æ¿
    await navigator.clipboard.writeText(codeToCopy);
    
    const copyText = copyButton.querySelector('.copy-text');
    if (copyText) {
      copyText.textContent = 'Copied!';
    }
    copyButton.classList.add('copied');

    // 2ç§’åæ¢å¤æŒ‰é’®çŠ¶æ€
    setTimeout(() => {
      if (copyText) {
        copyText.textContent = 'Copy';
      }
      copyButton.classList.remove('copied');
    }, 2000);
  } catch (err) {
    console.error('Failed to copy text: ', err);
    const copyText = copyButton.querySelector('.copy-text');
    if (copyText) copyText.textContent = 'Error';
     setTimeout(() => {
      if (copyText) {
        copyText.textContent = 'Copy';
      }
    }, 2000);
=======
const handleHintClick = () => {
  if (pendingJumpMessageId.value) {
    // Message is in another branch, switch to it
    navigateToMessage(pendingJumpMessageId.value);
    
    // Wait for DOM update (branch switch) then scroll
    nextTick(() => {
      forceScrollToBottom();
      shouldAutoScroll.value = true;
    });
  } else {
    // Message is in current view, just scroll
    forceScrollToBottom();
    shouldAutoScroll.value = true;
  }
};

// Handlers
const handleDelete = (id: string) => {
  if (isLoading.value) {
    alert("è¯·ç­‰å¾…ç”Ÿæˆå®Œæˆåå†åˆ é™¤æ¶ˆæ¯ã€‚");
    return;
  }
  if (confirm('ç¡®å®šè¦åˆ é™¤è¿™æ¡æ¶ˆæ¯åŠå…¶åç»­åˆ†æ”¯å—ï¼Ÿ')) {
    deleteMessage(id);
  }
};

const handleGlobalCollapse = () => {
  conversationHistory.value.forEach((msg) => {
    msg.collapsed = true;
  });
};

const handleGlobalExpand = () => {
  conversationHistory.value.forEach(msg => {
    msg.collapsed = false;
  });
};

const onSend = (text: string) => {
  if (settings.enableAutoCollapse) {
    conversationHistory.value.forEach(msg => {
      msg.collapsed = true;
    });
  }

  showCompletionHint.value = false;
  shouldAutoScroll.value = true;
  pendingJumpMessageId.value = null; // Reset pending jump
  scrollToBottom(true);

  sendMessage(
    text,
    {
      model: model.value,
      temperature: temperature.value,
      topP: topP.value,
      contextLength: contextLength.value
    },
    () => { // On Stream Update callback
       // Check if the generating message is in the current view
       if (isGeneratingMessageVisible.value) {
         if (shouldAutoScroll.value) {
           scrollToBottom(true);
         } else {
           showCompletionHint.value = true;
         }
       } else {
         // Generating message is NOT in view (user switched branch)
         // Always show hint so they can jump back
         showCompletionHint.value = true;
         
         // Capture the ID so we can jump to it even after generation finishes
         if (currentGeneratingMessageId.value) {
            pendingJumpMessageId.value = currentGeneratingMessageId.value;
         }
       }
    }
  ).then(() => {
    nextTick(() => inputRef.value?.focus());
  });
};

// Copy Code Logic (Event Delegation)
const handleCopyClick = async (event: MouseEvent) => {
  const target = event.target as HTMLElement;
  const copyButton = target.closest('.copy-code-button');

  if (!copyButton || copyButton.classList.contains('copied')) return;

  const wrapper = copyButton.closest('.code-block-wrapper');
  const preElement = wrapper?.querySelector('pre');

  if (preElement) {
    try {
      await navigator.clipboard.writeText(preElement.innerText);
      const copyText = copyButton.querySelector('.copy-text');
      if (copyText) copyText.textContent = 'Copied!';
      copyButton.classList.add('copied');
      setTimeout(() => {
        if (copyText) copyText.textContent = 'Copy';
        copyButton.classList.remove('copied');
      }, 2000);
    } catch (err) {
      console.error('Failed to copy', err);
    }
>>>>>>> 15934b618b20a489a8e8f54099124f82bf2036a5
  }
};

onMounted(() => {
<<<<<<< HEAD
  const SECRET_KEY = import.meta.env.VITE_ACCESS_KEY;
  if (!SECRET_KEY) {
    console.error("é”™è¯¯ï¼šæœªåœ¨ .env.local æ–‡ä»¶ä¸­è®¾ç½® VITE_ACCESS_KEY");
    isAuthenticated.value = false;
    return;
  }
  if (sessionStorage.getItem('app_access_key') === SECRET_KEY) {
    isAuthenticated.value = true;
  } else {
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    if (token === SECRET_KEY) {
      isAuthenticated.value = true;
      sessionStorage.setItem('app_access_key', SECRET_KEY);
      window.history.replaceState({}, document.title, window.location.pathname);
    }
  }

  if (isAuthenticated.value) {
    nextTick(() => { // ä½¿ç”¨ nextTick ç¡®ä¿ DOM å·²ç»æ¸²æŸ“
        textareaRef.value?.focus();
        const chatWindow = chatWindowRef.value;
        if (chatWindow) {
          chatWindow.addEventListener('scroll', handleScroll);
          // å…³é”®ï¼šåœ¨è¿™é‡Œä¸ºçˆ¶å®¹å™¨æ·»åŠ ç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
          chatWindow.addEventListener('click', handleChatWindowClick); 
        }
    });
  }
});

onUnmounted(() => {
  const chatWindow = chatWindowRef.value;
  if (chatWindow) {
    chatWindow.removeEventListener('scroll', handleScroll);
    // å…³é”®ï¼šç»„ä»¶é”€æ¯æ—¶ç§»é™¤ç›‘å¬å™¨ï¼Œé˜²æ­¢å†…å­˜æ³„æ¼
    chatWindow.removeEventListener('click', handleChatWindowClick); 
=======
  if (isAuthenticated.value) {
    nextTick(() => inputRef.value?.focus());
>>>>>>> 15934b618b20a489a8e8f54099124f82bf2036a5
  }
});
</script>

<style>
<<<<<<< HEAD
/* ... ä½ çš„æ‰€æœ‰ç°æœ‰ CSS æ ·å¼éƒ½ä¿ç•™ ... */
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background-color: #f4f4f9;
  margin: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  color: #333;
}

#app {
  width: 90%;
  max-width: 800px;
  height: 95vh;
  max-height: 900px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 4px 20px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  font-size: var(--base-font-size, 13px); /* ç¡®ä¿æœ‰è¿™ä¸€è¡Œ */
}

#header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0 20px;
  border-bottom: 1px solid #eee;
  background-color: #fafafa;
  flex-shrink: 0;
}

h1 {
  font-size: 1.1em;
  color: #444;
  margin: 0;
  padding: 15px 0;
}

#settings {
  display: flex;
  align-items: center;
  gap: 10px;
}

#settings select {
  padding: 5px 8px;
  border-radius: 6px;
  border: 1px solid #ddd;
  font-size: 0.9em;
  background-color: #fff;
}

#chat-window {
  flex-grow: 1;
  overflow-y: auto;
  padding: 15px;
  display: flex;
  flex-direction: column;
}

.message {
  display: flex;
  flex-direction: column;
  margin-bottom: 15px;
  max-width: 95%;
}

.message .role {
  font-weight: bold;
  font-size: 0.85em;
  margin-bottom: 4px;
  color: #555;
}

.message .text {
  padding: 10px 15px;
  border-radius: 16px;
  line-height: 1.5;
  word-wrap: break-word;
  text-align: left;
}

.message.user {
  align-self: flex-end;
  align-items: flex-end;
}

.message.user .text {
  background: #007bff;
  color: white;
  border-bottom-right-radius: 4px;
  max-width: 100%; 
  white-space: pre-wrap;
  overflow-wrap: break-word;
  word-break: break-word; /* æ–°å¢ï¼šæ›´å¼ºåŠ›åœ°å¤„ç†é•¿å•è¯æˆ–URLï¼Œç¡®ä¿å…¶åœ¨æ°”æ³¡å†…æ¢è¡Œ */
}

.message.model {
  align-self: flex-start;
  align-items: flex-start;
}

.message.model .text {
  background: #e9ecef;
  color: #333;
  border-bottom-left-radius: 4px;
  max-width: 100%;          /* 1. å®šæ­»å®½åº¦ï¼šå¼ºåˆ¶æ°”æ³¡å®½åº¦ä¸èƒ½è¶…è¿‡å…¶çˆ¶å®¹å™¨ (.message.model) çš„å®½åº¦ */
  overflow-wrap: break-word; /* 2. æ–‡æœ¬æ¢è¡Œï¼šç¡®ä¿æ°”æ³¡å†…çš„æ™®é€šé•¿æ–‡æœ¬å¯ä»¥æ¢è¡Œ */
  word-break: break-all;     /* 3. å¼ºåŠ›æ¢è¡Œï¼šè¿›ä¸€æ­¥ç¡®ä¿éä»£ç æ–‡æœ¬ä¸ä¼šæ’‘å¼€æ°”æ³¡ */
}

.token-info {
  font-size: 0.75em;
  color: #888;
  margin-top: 5px;
  display: flex;
  gap: 12px; /* å¢åŠ äº†é—´è· */
}
.message.user .token-info {
  align-self: flex-end;
}
.message.model .token-info {
  align-self: flex-start;
}
.token-info .received-chars {
  color: #666;
}

/* --- æ–°å¢ï¼šè´¹ç”¨ä¿¡æ¯æ ·å¼ --- */
.cost-info {
  color: #6c757d; /* ä½¿ç”¨æ›´æŸ”å’Œçš„é¢œè‰² */
  margin-top: 3px;
}

.completion-hint {
  position: absolute;
  bottom: 75px; /* è°ƒæ•´ä½ç½®ï¼Œä½¿å…¶åœ¨è¾“å…¥æ¡†ä¸Šæ–¹ */
  left: 50%;
  transform: translateX(-50%);
  z-index: 10;
  
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 20px;
  padding: 8px 16px;
  font-size: calc(var(--base-font-size, 13px) - 1px);
  font-weight: 500;
  cursor: pointer;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2);
  transition: opacity 0.3s ease, transform 0.3s ease;
}

.completion-hint:hover {
  background-color: #0056b3;
  transform: translateX(-50%) translateY(-2px);
}

#input-area {
  display: flex;
  align-items: flex-end;
  padding: 12px;
  border-top: 1px solid #eee;
  background-color: #fafafa;
  flex-shrink: 0;
}

#message-input {
  flex-grow: 1;
  border: 1px solid #ccc;
  border-radius: 18px;
  padding: 10px 15px;
  resize: none;
  font-size: 1em;
  font-family: inherit;
  line-height: 1.4;
  max-height: 120px;
  overflow-y: auto;
}

#message-input:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
}

#send-button {
  background: #007bff;
  color: white;
  border: none;
  border-radius: 50%;
  width: 44px;
  height: 44px;
  margin-left: 10px;
  cursor: pointer;
  font-size: calc(var(--base-font-size, 13px) * 1.4);
  display: flex;
  justify-content: center;
  align-items: center;
  transition: background-color 0.2s;
  flex-shrink: 0;
}

#send-button.stop-button {
  background-color: #dc3545;
}
#send-button.stop-button:hover {
  background-color: #c82333;
}

#send-button:hover {
  background: #0056b3;
}

#send-button:disabled {
  background-color: #a0a0a0;
  cursor: not-allowed;
}

.message.model .text pre {
  background-color: #282c34;
  color: #abb2bf;
  padding: 0.8em;
  margin: 0.5em 0;
  border-radius: 8px;
  overflow-x: auto; /* å…³é”®ï¼šè¿™æ¡è§„åˆ™æœ¬èº«æ˜¯æ­£ç¡®çš„ï¼Œç°åœ¨å®ƒçš„çˆ¶å…ƒç´ è¡Œä¸ºæ­£å¸¸äº†ï¼Œå®ƒå°±èƒ½æ­£ç¡®å·¥ä½œ */
  font-size: 0.9em;
  white-space: pre; /* æ–°å¢ï¼šæ˜ç¡®æŒ‡å®šä»£ç å—å†…çš„ç©ºç™½å’Œæ¢è¡Œè¡Œä¸ºï¼Œé˜²æ­¢æ„å¤–çš„è‡ªåŠ¨æ¢è¡Œ */
}
.message.model .text code {
  font-family: 'Courier New', Courier, monospace;
  background-color: rgba(0,0,0,0.08);
  padding: 2px 5px;
  border-radius: 4px;
}
.message.model .text pre > code {
  background-color: transparent;
  padding: 0;
  color: inherit;
}
.message.model .text blockquote {
  border-left: 3px solid #ccc;
  padding-left: 1em;
  margin: 0.5em 0;
  color: #666;
}
.message.model .text ul, .message.model .text ol {
  padding-left: 1.5em;
  margin: 0.5em 0;
}
.message.model .text p {
  margin: 0.5em 0;
}
.message.model .text p:first-child {
  margin-top: 0;
}
.message.model .text p:last-child {
  margin-bottom: 0;
}
.message.model .text strong {
  font-weight: bold;
}

/* --- æ–°å¢ï¼šè®¿é—®å—é™é¡µé¢çš„æ ·å¼ --- */
.access-denied {
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  height: 100%;
  padding: 20px;
  text-align: center;
  background-color: #f8f9fa;
  color: #495057;
}

.access-denied h2 {
  font-size: 2em;
  margin-bottom: 15px;
}

.access-denied p {
  font-size: 1.1em;
  margin-bottom: 20px;
  max-width: 500px;
  line-height: 1.6;
}

.access-denied code {
  background-color: #e9ecef;
  padding: 4px 8px;
  border-radius: 4px;
  font-family: 'Courier New', Courier, monospace;
  color: #c7254e;
}

.access-denied .warning {
  background-color: #fff3cd;
  color: #856404;
  padding: 10px 15px;
  border-radius: 6px;
  border: 1px solid #ffeeba;
  max-width: 90%;
  margin-top: 20px;
  margin-bottom: 20px;
}

/* 
 * ===================================================================
 *  æœ€ç»ˆçš„ã€ä¿è¯æœ‰æ•ˆçš„æ»šåŠ¨æ¡æ ·å¼ (Chrome/WebKit æ ¸å¿ƒ)
 * ===================================================================
 */

/* 
 * -------------------------------------------------------------------
 *  A. ç¾åŒ–ã€é¡µé¢ä¸»æ»šåŠ¨æ¡ã€‘(åº”ç”¨æµ…è‰²ä¸»é¢˜)
 * -------------------------------------------------------------------
 *  æˆ‘ä»¬ä¸å†å¯¹ #chat-window è¿›è¡Œä¿®æ”¹ï¼Œè€Œæ˜¯ç›´æ¥ä¿®æ”¹å…¨å±€çš„æ»šåŠ¨æ¡ã€‚
 *  åœ¨æ‚¨çš„å¸ƒå±€ä¸­ï¼Œè¿™ä¼šç¨³å®šåœ°åº”ç”¨åˆ°ä¸»èŠå¤©çª—å£çš„æ»šåŠ¨æ¡ä¸Šã€‚
 */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
  background-color: #f1f1f1; /* è½¨é“èƒŒæ™¯è‰² */
}

/* å®šä¹‰æ»‘å—çš„æ ·å¼ */
::-webkit-scrollbar-thumb {
  background-color: #c1c1c1; /* æ»‘å—é¢œè‰² */
  border-radius: 4px;
}

/* é¼ æ ‡æ‚¬æµ®åœ¨æ»‘å—ä¸Šæ—¶çš„æ ·å¼ */
::-webkit-scrollbar-thumb:hover {
  background-color: #a8a8a8; /* æ»‘å—é¢œè‰²åŠ æ·± */
}


/* 
 * -------------------------------------------------------------------
 *  B. ç¾åŒ–ã€ä»£ç å—å†…éƒ¨ã€‘çš„ã€æ°´å¹³ã€‘æ»šåŠ¨æ¡ (åº”ç”¨æ·±è‰²ä¸»é¢˜)
 *     è¿™éƒ¨åˆ†æ ·å¼å…·æœ‰æ›´é«˜çš„ç‰¹å¼‚æ€§ï¼Œä¼šè¦†ç›–ä¸Šé¢çš„å…¨å±€è®¾ç½®ã€‚
 * -------------------------------------------------------------------
 */
.message.model .text pre::-webkit-scrollbar {
  /* å°ºå¯¸å’Œè½¨é“èƒŒæ™¯åœ¨ä»£ç å—ä¸­éœ€è¦é‡æ–°å®šä¹‰ */
  height: 8px;
  background-color: #3d4451; /* ä»£ç å—æ»šåŠ¨æ¡çš„è½¨é“é¢œè‰² */
}

/* å®šä¹‰ä»£ç å—ä¸­æ»‘å—çš„æ ·å¼ */
.message.model .text pre::-webkit-scrollbar-thumb {
  background-color: #6c757d; /* ä»£ç å—æ»‘å—é¢œè‰² */
  border-radius: 4px;
  border: 2px solid #3d4451; /* ä½¿ç”¨è¾¹æ¡†åˆ›å»ºå†…è¾¹è·æ•ˆæœï¼Œè®©æ»‘å—çœ‹èµ·æ¥æ›´ç²¾è‡´ */
}

/* é¼ æ ‡æ‚¬æµ®åœ¨ä»£ç å—æ»‘å—ä¸Šæ—¶çš„æ ·å¼ */
.message.model .text pre::-webkit-scrollbar-thumb:hover {
  background-color: #9ea5ab; /* æ‚¬æµ®æ—¶æ»‘å—é¢œè‰²å˜äº® */
}

/* 
 * ===================================================================
 *  ä»£ç å—å¤åˆ¶æŒ‰é’®æ ·å¼ (V2 - ä¸“ä¸šç‰ˆ)
 * ===================================================================
 */

/* 
  1. Wrapper å®¹å™¨: 
  - æˆä¸ºè§†è§‰ä¸Šçš„ä»£ç å—ä¸»ä½“ (èƒŒæ™¯ã€åœ†è§’ç­‰)
  - ä½œä¸ºæŒ‰é’®çš„ç›¸å¯¹å®šä½çˆ¶çº§
*/
.code-block-wrapper {
  position: relative;
  background-color: #2e3440; /* Nord ä¸»é¢˜æš—è‰²èƒŒæ™¯ */
  border-radius: 8px;
  margin: 1em 0;
  padding: 1em; /* ä¸ºå†…éƒ¨<pre>æä¾›ç©ºé—´ */
}

/* 
  2. å†…éƒ¨ <pre> æ ‡ç­¾: 
  - é‡ç½®å…¶æ‰€æœ‰æ ·å¼ï¼Œä½¿å…¶é€æ˜åœ°å­˜åœ¨äº Wrapper å†…éƒ¨
  - å®ƒçš„å”¯ä¸€ä½œç”¨æ˜¯ä¿ç•™ä»£ç çš„æ ¼å¼
*/
.message.model .text .code-block-wrapper pre {
  margin: 0;
  padding: 0;
  background-color: transparent;
  overflow-x: auto; /* ä¿æŒä»£ç æ°´å¹³æ»šåŠ¨ */
}

/* 
  3. å¤åˆ¶æŒ‰é’®:
  - ç»å¯¹å®šä½åˆ° Wrapper çš„å³ä¸Šè§’å†…éƒ¨
  - é»˜è®¤éšè—ï¼Œæ‚¬æµ®æ—¶å‡ºç°ï¼Œäº¤äº’å‹å¥½
*/
.copy-code-button {
  position: absolute;
  top: 0.75em;
  right: 0.75em;
  
  display: flex;
  align-items: center;
  gap: 0.5em; /* å›¾æ ‡å’Œæ–‡å­—çš„é—´è· */

  padding: 0.35em 0.6em;
  background-color: rgba(216, 222, 233, 0.1); /* Nord ä¸»é¢˜çš„åŠé€æ˜èƒŒæ™¯ */
  color: #d8dee9; /* Nord ä¸»é¢˜çš„æ–‡å­—é¢œè‰² */
  border: 1px solid rgba(216, 222, 233, 0.15);
  border-radius: 6px;
  font-size: 0.875rem;
  font-family: inherit;
  cursor: pointer;
  
  opacity: 0; /* é»˜è®¤å®Œå…¨é€æ˜ */
  transform: translateY(-5px); /* é»˜è®¤å‘ä¸Šç§»åŠ¨ä¸€ç‚¹ */
  transition: opacity 0.2s ease-in-out, transform 0.2s ease-in-out, background-color 0.2s;
  z-index: 10;
}

/* 
  4. äº¤äº’æ•ˆæœ:
  - å½“é¼ æ ‡æ‚¬æµ®åœ¨ã€æ•´ä¸ªä»£ç å—ã€‘ä¸Šæ—¶ï¼ŒæŒ‰é’®å¹³æ»‘åœ°æµ®ç°å‡ºæ¥
*/
.code-block-wrapper:hover .copy-code-button {
  opacity: 1;
  transform: translateY(0);
}

.copy-code-button:hover {
  background-color: rgba(216, 222, 233, 0.25);
}

.copy-code-button:active {
  background-color: rgba(216, 222, 233, 0.3);
}

/* 
  5. å¤åˆ¶æˆåŠŸçŠ¶æ€:
  - æŒ‰é’®èƒŒæ™¯å˜ç»¿ï¼Œæ–‡å­—å’Œå›¾æ ‡å˜ç™½
*/
.copy-code-button.copied {
  background-color: #5e81ac; /* Nord ä¸»é¢˜çš„è“è‰²ï¼Œè¡¨ç¤ºæˆåŠŸ */
  border-color: #5e81ac;
  color: #eceff4;
}

.copy-code-button .copy-text {
  line-height: 1; /* ç¡®ä¿æ–‡å­—å‚ç›´å±…ä¸­ */
}
=======
/* Global Layout Styles */
body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  background-color: #f4f4f9; margin: 0; display: flex; justify-content: center; align-items: center;
  height: 100vh; color: #333;
}

#app {
  width: 90%; max-width: 800px; height: 95vh; max-height: 900px; background: #fff;
  border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.1); display: flex;
  flex-direction: column; overflow: hidden; font-size: var(--base-font-size, 13px);
  position: relative; 
}

#chat-window { 
  flex-grow: 1; 
  overflow-y: auto; 
  padding: 15px; 
  display: flex; 
  flex-direction: column; 
  text-align: left; 
}

.completion-hint {
  position: absolute; bottom: 130px; 
  left: 50%; transform: translateX(-50%); z-index: 10;
  background-color: #007bff; color: white; border: none; border-radius: 20px; padding: 8px 16px;
  font-size: calc(var(--base-font-size, 13px) - 1px); font-weight: 500; cursor: pointer;
  box-shadow: 0 2px 10px rgba(0,0,0,0.2); transition: opacity 0.3s ease, transform 0.3s ease;
}
.completion-hint:hover { background-color: #0056b3; transform: translateX(-50%) translateY(-2px); }

/* Scrollbars */
::-webkit-scrollbar { width: 8px; height: 8px; background-color: #f1f1f1; }
::-webkit-scrollbar-thumb { background-color: #c1c1c1; border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background-color: #a8a8a8; }
>>>>>>> 15934b618b20a489a8e8f54099124f82bf2036a5
</style>